```{r}
# cox-ph full model validation
library(glmnet)
library(survival)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(survminer)
# load UF validation set 
names(delivery_final_v9)[names(delivery_final_v9)== "parity"]<-"EPIS_PARA_COUNT"
names(delivery_final_v9)[names(delivery_final_v9)== "gravidity"]<-"EPIS_GRAVIDA_COUNT"
names(delivery_final_v9)[names(delivery_final_v9)== "mom_age_delivery"]<-"age"



delivery_final_v9$time_to_deliver<-as.numeric(delivery_final_v9$time_to_deliver)

df = delivery_final_v9

df=df%>%
  group_by(mom_id)%>%
  ungroup()


# plot individual scatterplots
p1 = ggplot(df, aes(x = creatinine_value, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p2 = ggplot(df, aes(x = Hematocrit, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p3 = ggplot(df, aes(x = Hemoglobin, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p4 = ggplot(df, aes(x = Mean_Corpuscular_Hgb, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p5 = ggplot(df, aes(x = Mean_Corpuscular_Hgb_Conc, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p6= ggplot(df, aes(x = Mean_Corpuscular_Vol, y= time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p7 = ggplot(df, aes(x = Red_Blood_Cell_Count, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p8 = ggplot(df, aes(x = Red_Cell_Distribution_Width, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p9= ggplot(df, aes(x = White_Blood_Cell_Count, y= time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p10 = ggplot(df, aes(x = Platelet_Count, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p11 = ggplot(df, aes(x = AST, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p12= ggplot(df, aes(x = ALT, y= time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12, ncol=3)

p13 = ggplot(df, aes(x = BPDiaMax, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p14 = ggplot(df, aes(x = BPDiaMin, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p15= ggplot(df, aes(x = BPDiaMean, y= time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p16 = ggplot(df, aes(x = BPDiaSD, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p17 = ggplot(df, aes(x = BPSysMax, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p18= ggplot(df, aes(x = BPSysMin, y= time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p19 = ggplot(df, aes(x = BPSysMean, y=time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
p20= ggplot(df, aes(x = BPSysSD, y= time_to_deliver))+geom_point(col = "steelblue", size = 0.5)
grid.arrange(p13,p14,p15,p16,p17,p18,p19,p20, ncol=4)


# Model validation ----------------------------------
df = df%>%select(diag_GA, AST, White_Blood_Cell_Count,SeverePE,BPDiaMax,BPSysMin,EPIS_PARA_COUNT,creatinine_value,BPDiaMin,BPDiaSD,BPSysMean, time_to_deliver)
# fill RRSD with 0
df$RRSD = rep(0, nrow(df))
# convert zeros in time_to_deliver to 0.5
for(i in c(1:nrow(df))){
  if(df$time_to_deliver[i] == 0){
    df$time_to_deliver[i] = 0.5
  }
}

df$SeverePE<-as.numeric(df$SeverePE)

# scale numeric variables
for(i in c(1:11)){
  df[,i] = scale(df[,i], center = F)
}


xtest = data.matrix(df%>%dplyr::select(-time_to_deliver))
ytest = df%>%dplyr::select(time_to_deliver)
ytest = data.frame(time = unlist(ytest), status = rep(1, length(ytest)))
colnames(ytest)[1] = "time"

#calculate c-index for cox-ph using pre-trained model
load("coxph_full_model0425.RData")
test_ridge <- predict(train_ridge, unlist(xtest) ,s=train_ridge$lambda.min,type='link')
cindex_ridge <- round(Cindex(test_ridge, ytest),3)
cindex_ridge

# plot the predicted vs true value scatterplot
result = data.frame(test_ridge, ytest[,1])
colnames(result) = c("Predicted", "True")
p_result = ggplot(result, aes(x = Predicted, y=True))+geom_point(col = "steelblue", size=0.5)+
  annotate("text",x=max(result$Predict)-1, y=max(result$True),label = sprintf("c-index:%f", cindex_ridge))
p_result

# plot KM curves
High_risk = ifelse(result$Predicted>median(result$Predicted), T, F)
result$high_risk = High_risk
cox = survfit(Surv(True, rep(1, nrow(result)))~high_risk, data = result)
eope_km = ggsurvplot(cox, result, conf.int = T, pval = T, pval.method = T, pval.size = 4, pval.coord = c(70, 0.7), pval.method.coord = c(70, 0.8),
                     font.x = 12,font.y = 12, font.tickslab=12, font.title = 9, font.legend = 12,xlab = NULL)
eope_km

# build coxph full model
# x_train = as.matrix(df%>%dplyr::select(-time_to_deliver))
# y_train = df%>%select(time_to_deliver)
# y_train = data.frame(time = unlist(y_train), status = rep(1, length(y_train)))
# colnames(y_train)[1] = "time"
## y_train = as.matrix(y_train)
# 
# train_ridge <-cv.glmnet(x_train, y_train, nfolds = 5, family = "cox", alpha = 0)
# train_theta = predict(train_ridge, x_train, s=train_ridge$lambda.min,type='link')
 #cindex_ridge_train = Cindex(train_theta, y_train)
# cindex_ridge_train
# save(train_ridge,file = "coxph_full_model0425.RData")
```